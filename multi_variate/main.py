import sys
# FIXME if sys.path.append is important should move to be function argument
# sys.path.append('/orfeo/LTS/LADE/LT_storage/lvaleriani/CNA/segmentation/claspy')

import os
import numpy as np
import argparse

from plot import *
from functions import *

# TODO: Why are these constants? Why is the main function looping through
# thr = [1e-15, 1e-10, 1e-5]
# wsize = [5, 10, 50]
#threshold = 1e-15
#window_size = 10

# TODO inherit from some claspy class to run error checking on kwargs? Is argparse type enough
class MultivariateClaSP:
    def __init__(self, input, mode, out_dir, **kwargs) -> None:
        self.input = input
        self.mode = mode
        self.out_dir = out_dir

        self._check_args()

    def _check_args(self):
        # TODO more specific error checking
        if os.path.isfile(self.input) or self.input.endswith(".csv") is False:
            raise TypeError(f"input file must be csv, not {self.input}")
        # should be all that is needed as input is already checked
        if self.out_dir is None:
            self.output_dir = os.path.dirname(self.input)
        if type(self.mode) == str or self.mode in ["max", "sum", "mult"] is False:
            raise TypeError(f"mode must be string of one of the following options: max, sum, mult")

        

def main(input, mode, out_dir, **kwargs):
    # TODO input checking instead of this if else stuff
    # TODO if sim is needed, is this program only applicable to data generated by races?
    if os.path.isfile(input) and input.endswith(".csv"):

        if out_dir is None:
            output_dir = os.path.dirname(input)
        # FIXME unsafe in case of typos from user
        os.makedirs(output_dir, exist_ok=True)

        name = f'{mode}_{kwargs['window_size']}_{kwargs['threshold']}'
        # returns dictionary now to preserve variable names
        original_data = get_original_data_plot(input, 
                                                save = True,
                                                out_file = output_dir)
        bps = np.sort(original_data[-1])[1:-1]
        print(bps)
        np.save(file = f'{os.path.join(out_dir, sim)}/{c}_bp.npy', arr = np.array(bps))
        # TODO: change to acess via original data list
        time_series = np.array([i for i in original_data.values()[:-1]])
        # n_timepoints = time_series.shape[1]

        # now done in multivariateClaSP init
        # min_seg_size = window_size * excl_radius
        # n_segments = time_series.shape[1] // min_seg_size
        
        try:
            multivariate_clasp_objects = {}
            for i in range(0, len(original_data)-2):
                ts_obj = MultivariateClaSPSegmentation(original_data[original_data.keys()[i]], **kwargs)
                ts_obj.n_timepoints = time_series.shape[1]
                ts_obj.n_segments = ts_obj.n_timepoints // ts_obj.min_seg_size
                ts_obj.get_first_cp()
                multivariate_clasp_objects[original_data.keys()[i]] = ts_obj


            
            # call with profiles for each time series
            # TODO: is there a better way to do this?? parse dict values into variables of name key
            cp = take_first_cp(multivariate_clasp_objects["dr"].profile,
                                multivariate_clasp_objects["baf"].profile,
                                multivariate_clasp_objects["vaf"].profile,
                                mode)
            # feed in created objects to be checked
            validate_first_cp(multivariate_clasp_objects=multivariate_clasp_objects.values(), cp=cp)
            
            CP = find_cp_iterative(multivariate_clasp_objects, mode)
                
            np.save(file = f'{output_dir}/{name}.npy', arr = np.array(CP))

            plot_profile(multivariate_clasp_objects, bps, CP, 
                                title = f'{c}-{name}', 
                                save = True, 
                                out_file = output_dir, 
                                mode = f'{mode}_{name}')
        except:
            print(f'Not passe: {name}')
            pass


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-input', type = str, help = "input path to smoothed data csv file")
    parser.add_argument('-mode', type = str, default = "mult", help= "type of cp choice bw: max, sum, mult")
    parser.add_argument('-output', type = str, default=None, help = "output path")
    # optional args to be passed to ClaSP, called in main as **kwargs
    parser.add_argument('--n_segments', type = str, default = "learn")
    parser.add_argument('--n_estimators', type = int, default = 10)
    parser.add_argument('--window_size', type = int, default = 5)
    parser.add_argument('--k_neighbors', type = int, default = 3)
    parser.add_argument('--distance', type = str, default =  "euclidean_distance")
    parser.add_argument('--score', type = str, default = "roc_auc")
    parser.add_argument('--early_stopping', type = bool, default = True)
    parser.add_argument('--validation', type = str, default = "significance_test")
    parser.add_argument('--threshold', type = float, default = 1e-15)
    parser.add_argument('--excl_radius', type = int, default = 5)
    parser.add_argument('--n_jobs', type = int, default = 1)
    parser.add_argument('--random_state', type = int, default = 2357)
    
    args = parser.parse_args() 
    main(args.input, args.mode, args.output, args.n_segments, args.n_estimators, args.window_size, args.k_neighbors, args.distance, args.score, args.early_stopping,
         args.validation, args.threshold, args.excl_radius, args.n_jobs, args.random_state)