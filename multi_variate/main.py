import sys
# FIXME if sys.path.append is important should move to be function argument
# sys.path.append('/orfeo/LTS/LADE/LT_storage/lvaleriani/CNA/segmentation/claspy')

import os
import numpy as np
import argparse

from plot import *
from functions import *

# TODO inherit from some claspy class to run error checking on kwargs? Is argparse type enough
class MultivariateClaSP:
    def __init__(self, input, mode, out_dir, **kwargs) -> None:
        self.input = input
        self.mode = mode
        self.out_dir = out_dir
        self.kwargs = kwargs

        self._check_args()

    def _check_args(self):
        # TODO more specific error checking
        if os.path.isfile(self.input) or self.input.endswith(".csv") is False:
            raise TypeError(f"input file must be csv, not {self.input}")
        # should be all that is needed as input is already checked
        if self.out_dir is None:
            self.out_dir = os.path.dirname(self.input)
        if type(self.mode) == str or self.mode in ["max", "sum", "mult"] is False:
            raise TypeError(f"mode must be string of one of the following options: max, sum, mult")
        # if all(self.kwargs["frequencies"], str) is False:
        #     raise TypeError(f"If frequencies is specified, list items must be strings")


    def analyze_time_series(self):
        # TODO if sim is needed, is this program only applicable to data generated by races?
        if os.path.isfile(input) and input.endswith(".csv"):

            name = f'{self.mode}_{self.kwargs['window_size']}_{self.kwargs['threshold']}'

            # returns dictionary to preserve variable names
            original_data = get_data_csv(input)

            # sort bps
            self.bps = np.sort(original_data["bps"])[1:-1]

            # store frequencies and then delete from kwargs as they are not a param to be passed to MultivariateClaSPSegmentation
            freqs = self.kwargs["frequencies"]
            del self.kwargs["frequencies"]
            time_series = np.array([i for i in original_data[i] if i in freqs])
            # n_timepoints = time_series.shape[1]

            # now done in multivariateClaSP init
            # min_seg_size = window_size * excl_radius
            # n_segments = time_series.shape[1] // min_seg_size
            try:
                self.multivariate_clasp_objects = {}
                for i in freqs:
                    ts_obj = MultivariateClaSPSegmentation(original_data[i], **self.kwargs)
                    ts_obj.n_timepoints = time_series.shape[1]
                    ts_obj.n_segments = ts_obj.n_timepoints // ts_obj.min_seg_size
                    ts_obj.get_first_cp()
                    self.multivariate_clasp_objects[i] = ts_obj


                # call with profiles for each time series
                cp = take_first_cp(self.multivariate_clasp_objects,
                                    self.mode)
                # feed in created objects to be checked
                validate_first_cp(multivariate_clasp_objects=self.multivariate_clasp_objects, cp=cp)
                
                self.CP = find_cp_iterative(self.multivariate_clasp_objects, self.mode)
                
                # TODO Move all of these calls below to be called seperately with class attributes
                # save out bps and final cp
                np.save(file = os.path.join(self.out_dir, "_bp.npy"), arr = np.array(self.bps))
                np.save(file = f'{self.out_dir}/{name}.npy', arr = np.array(self.CP))

                plot_profile(self.multivariate_clasp_objects, self.bps, self.CP, 
                                    title = name, 
                                    save = True, 
                                    out_file = self.out_dir, 
                                    mode = f'{self.mode}_{name}')
            except:
                print(f'Not passed: {name}')
                pass


# TODO probably best to move this to separate entrance module now
if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-input', type = str, help = "input path to smoothed data csv file")
    parser.add_argument('-mode', type = str, default = "mult", help= "type of cp choice bw: max, sum, mult")
    parser.add_argument('-output', type = str, default=None, help = "output path")
    # optional args to be passed to ClaSP, called in main as **kwargs
    parser.add_argument('--frequencies', type=list, default=["vaf", "baf", "dr"])
    parser.add_argument('--n_segments', type = str, default = "learn")
    parser.add_argument('--n_estimators', type = int, default = 10)
    parser.add_argument('--window_size', type = int, default = 5)
    parser.add_argument('--k_neighbors', type = int, default = 3)
    parser.add_argument('--distance', type = str, default =  "euclidean_distance")
    parser.add_argument('--score', type = str, default = "roc_auc")
    parser.add_argument('--early_stopping', type = bool, default = True)
    parser.add_argument('--validation', type = str, default = "significance_test")
    parser.add_argument('--threshold', type = float, default = 1e-15)
    parser.add_argument('--excl_radius', type = int, default = 5)
    parser.add_argument('--n_jobs', type = int, default = 1)
    parser.add_argument('--random_state', type = int, default = 2357)
    
    args = parser.parse_args()
    # gross
    MultivariateClaSP(args.input, args.mode, args.output, args.frequencies, args.n_segments, args.n_estimators, args.window_size, args.k_neighbors,
                      args.distance, args.score, args.early_stopping, args.validation, args.threshold, args.excl_radius, args.n_jobs, args.random_state).analyze_time_series()